# 重構計畫：一個務實的方法

## 1. 目標：停止腐爛 (Stop the Rot)

我們現在的程式碼正變得越來越複雜，邏輯分散在各處。這不是什麼「架構挑戰」，而是程式碼正在腐爛的徵兆。我們的目標很簡單：在它變得無法維護之前，清理乾淨。

**核心目標只有三個：**
1.  **讓程式碼易於理解。** 一個新來的工程師應該能在一天內看懂核心邏輯，而不是花一週時間研究你畫的那些複雜架構圖。
2.  **讓程式碼易於測試。** 如果測試很難寫，那說明你的設計是垃圾。
3.  **絕不破壞 API。** 我們對使用者（前端或其他服務）的承諾是神聖不可侵犯的。

## 2. 規則：保持簡單 (Keep It Simple, Stupid)

忘掉那些花俏的術語。我們的規則很直接，來自於數十年維護大型專案的經驗。

- **規則一：資料結構優先 (Data Structures First)**
  > "爛的程式設計師擔心程式碼，好的程式設計師擔心資料結構。"

  程式碼的複雜性來自於糟糕的資料結構。我們必須將核心的資料模型（病患、問卷）與它們在資料庫中的儲存方式（SQLAlchemy models）徹底分開。這能創造一個清晰的邊界，防止資料庫的實作細節污染我們的業務邏輯。

- **規則二：絕不破壞 API (No Broken APIs)**
  > "我們不破壞使用者空間！"

  API 就是我們的「使用者空間」。在修改任何一行程式碼之前，我們必須為現有的 API 建立一套完整的端到端測試。這個測試套件是我們的安全網，在重構的每一步保護我們。

- **規則三：邏輯集中管理 (Logic Belongs in One Place)**
  業務邏輯應該只存在於一個地方：我們的核心服務或領域物件中。絕不能出現在 API 控制器、資料庫查詢或任何其他奇怪的角落。我之前對 `patient_service` 的重構就是一個例子。

- **規則四：寫有意義的測試 (Write Tests That Matter)**
  我們不需要 BDD 那套繁文縟節。Gherkin 語法如果沒有非技術人員持續維護，很快就會變成一堆無用的廢話。我們需要兩種測試：
  1.  **單元測試：** 針對核心業務邏輯。
  2.  **API 契約測試：** 針對 API 的輸入和輸出，確保我們的承諾不變。

- **規則五：一個不能失敗的測試是無用的 (A Test That Can't Fail Is Useless)**
  TDD 的核心循環是「紅-綠-重構」。**「紅」——也就是先看到測試失敗——是這其中最重要也最常被忽略的一步。**

  為什麼？因為一個從一開始就通過的測試是不可信的。你不知道它通過是因為你的程式碼是對的，還是因為你的測試本身就是個不會報警的廢物。它可能根本沒有執行到你想要測試的程式碼，或者它的斷言邏輯本身就是錯的。

  **先看到失敗，是在驗證你的測試本身是有效的。** 它證明了這個測試能夠在你還沒有實現功能時，準確地發現「缺失」。

  我們的流程必須是：
  1.  **寫測試**：根據需求，寫一個測試案例。
  2.  **執行測試並確認它失敗 (🔴 紅)**：這是對測試的測試。如果它沒有因為功能缺失而失敗，你的測試就是垃圾，回到上一步重寫它。
  3.  **寫最小量的程式碼**：剛好能讓這個測試通過即可，不要多寫。
  4.  **執行測試並確認它通過 (🟢 綠)**：證明你的程式碼滿足了測試定義的需求。
  5.  **重構 (🔵 藍)**：現在你可以安心地清理和優化你的程式碼，因為有測試在保護你。

  這個紀律可以避免你寫出一堆看似通過、實則毫無用處的「安慰劑測試」。

## 3. 計畫：一步一步來

這個計畫沒有花俏的階段劃分，只有一系列必須按順序完成的務實步驟。

### 第 0 步：建立安全網 (Build the Safety Net)

**此步驟完成前，不允許任何重構。**

1.  **鎖定 API 契約**：使用 OpenAPI (Swagger) 為**所有**現有的 API 端點編寫規格文件。每個參數、每個響應欄位都必須被精確記錄。
2.  **編寫契約測試**：使用 `pytest` 編寫一套測試，直接透過 HTTP 呼叫 API 端點，並嚴格驗證其返回的 JSON 是否與 OpenAPI 規格完全一致。這套測試將成為我們 CI/CD 的一部分。

### 第 1 步：清理核心 (`web-app`)

1.  **分離資料模型**：
    - 在 `app/core/domain`（或者就叫 `app/core/data_models`，名字不重要，重要的是概念）目錄下，建立純粹的 Python 類別來代表我們的核心資料，如 `Patient`, `Questionnaire`。它們不應該知道資料庫的存在。
    - 現有的 SQLAlchemy `models` 只用於資料持久化，作為倉儲層的內部實現細節。

2.  **簡化服務層**：
    - 重構現有的服務（如 `patient_service`），使其接收和返回這些純粹的資料物件，而不是 SQLAlchemy 的模型實例。
    - 服務層負責協調流程，但不應包含複雜的業務規則。

3.  **將邏輯內聚到資料中**：
    - 將與特定資料模型緊密相關的業務邏輯（例如 `calculate_patient_risk`）移到資料物件自身的方法中（例如 `patient.calculate_risk()`）。這讓物件的行為更加內聚，也更符合物件導向的「品味」。

4.  **堅持 TDD**：
    - 所有新的業務邏輯都必須先寫一個失敗的單元測試，然後再寫實現程式碼。這是紀律。

### 第 2 步：隔離元件 (Isolate Components)

1.  **明確邊界**：`web-app` 和 `ai-worker` 是兩個獨立的服務。它們之間只允許透過經過第 0 步驗證的 API 進行通訊。嚴禁任何後門（如共享資料庫、共享程式碼）。
2.  **清理 `ai-worker`**：參照 `web-app` 清理後的新結構，對 `ai-worker` 進行同樣的簡化和分層。

## 4. 我們不做什麼 (What We Are NOT Doing)

- **我們不會去實現教科書上的「洋蔥架構」或「DDD」。** 對於我們目前的規模來說，這是殺雞用牛刀。我們只取其精華（關注點分離），並以最簡單、最務實的方式應用它。

- **我們不會去寫 Gherkin 檔案 (`.feature`)。** 除非你的產品經理承諾親自編寫並維護它們，否則這只會增加開發的負擔。用 `pytest` 寫出清晰、描述性強的測試就足夠了。

這個計畫的核心是**實用主義**。我們的目標是交付一個更健壯、更易於維護的系統，而不是一篇可以發表的學術論文。現在，停止空談，開始寫程式碼。
